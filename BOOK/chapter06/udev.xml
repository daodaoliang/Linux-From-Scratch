<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-system-udev" role="wrap">
  <?dbhtml filename="udev.html"?>

  <title>Udev-&udev-version;</title>

  <indexterm zone="ch-system-udev">
    <primary sortas="a-Udev">Udev</primary>
  </indexterm>

  <sect2 role="package">
    <title/>

    <para>The Udev package contains programs for dynamic creation of device
    nodes.</para>

    <segmentedlist>
      <segtitle>&buildtime;</segtitle>
      <segtitle>&diskspace;</segtitle>

      <seglistitem>
        <seg>&udev-ch6-sbu;</seg>
        <seg>&udev-ch6-du;</seg>
      </seglistitem>
    </segmentedlist>

  </sect2>

  <sect2 role="installation">
    <title>Installation of Udev</title>

    <para>The udev-config tarball contains LFS-specific files used to configure
    Udev.</para>

<screen><userinput>tar xf ../&udev-config;.tar.bz2</userinput></screen>

    <para>Create some devices and directories that Udev cannot handle due to
    them being required very early in the boot process:</para>

<screen><userinput>install -dv /lib/{firmware,udev/devices/{pts,shm}}
mknod -m0666 /lib/udev/devices/null c 1 3
ln -sv /proc/self/fd /lib/udev/devices/fd
ln -sv /proc/self/fd/0 /lib/udev/devices/stdin
ln -sv /proc/self/fd/1 /lib/udev/devices/stdout
ln -sv /proc/self/fd/2 /lib/udev/devices/stderr
ln -sv /proc/kcore /lib/udev/devices/core</userinput></screen>

    <para>Compile the package:</para>

<screen><userinput>make EXTRAS="extras/ata_id extras/cdrom_id extras/edd_id \
            extras/firmware extras/floppy extras/path_id \
            extras/scsi_id extras/usb_id extras/volume_id"</userinput></screen>

    <variablelist>
      <title>The meaning of the make option:</title>

      <varlistentry>
        <term><parameter>EXTRAS=...</parameter></term>
        <listitem>
          <para>This builds several helper binaries that can aid in writing custom
          Udev rules.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>To test the results, issue:
    <userinput>make test</userinput>.</para>

    <para>Install the package:</para>

<screen><userinput>make DESTDIR=/ \
    EXTRAS="extras/ata_id extras/cdrom_id extras/edd_id \
            extras/firmware extras/floppy extras/path_id \
            extras/scsi_id extras/usb_id extras/volume_id" install</userinput></screen>

    <variablelist>
      <title>The meaning of the make parameter:</title>

      <varlistentry>
        <term><parameter>DESTDIR=/</parameter></term>
        <listitem>
          <para>This prevents the Udev build process from killing any
          <command>udevd</command> processes that may be running on the
          host system.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Udev's configuration is far from ideal by default, so install
    the configuration files here:</para>

<!-- FIXME: 90-bug.rules should be removed from the tarball once the book is released -->
<screen><userinput>cp -v &udev-config;/[0-9]* /etc/udev/rules.d/</userinput></screen>

    <para>Now install a helper script that is not included in the main Udev
    tarball:</para>

<screen><userinput>install -v -m 744 &udev-config;/write_cd_aliases /lib/udev/</userinput></screen>

    <para>Install the documentation that explains how to create Udev rules:</para>

<screen><userinput>install -m644 -D -v docs/writing_udev_rules/index.html \
    /usr/share/doc/udev-&udev-version;/index.html</userinput></screen>

    <important>

      <para>When Udev is started by the LFS-Bootscripts, a replay of all kernel
      device events happens. These events tell Udev what devices exist.
      Sometimes the Udev bootscript doesn't wait long enough for
      <command>udevd</command> to process all of the replayed events and
      consequently the devices for those missed events are not created before the
      script exits. Since <command>udevd</command> is still running in the
      background, the devices will be created a few milliseconds later, but the
      next bootscript to run may require a device to exist before it has been
      created. To avoid such missed events, and to avoid hardcoding an overly
      long wait time, It is recommended that you run the following commands to
      aid the LFS development team in debugging these missed events and finding
      an acceptable solution more quickly.</para>

      <para>First, create a simple C file:</para>

<screen><userinput>cat &gt; bug.c &lt;&lt; EOF
<literal>/* Simple event recorder */
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argz.h&gt;
int main(int argc, char * argv[])
{
  char * envar;
  char * envz;
  size_t len;
  int bug;
  bug = open("/dev/bug", O_WRONLY | O_APPEND);
  if (bug == -1)
    return 0;

  /* Ignore everything USB-related to avoid spamming the list */
  envar = getenv("PHYSDEVPATH");
  if (envar &amp;&amp; strstr(envar, "usb"))
    return 0;
  envar = getenv("DEVPATH");
  if (envar &amp;&amp; strstr(envar, "usb"))
    return 0;

  setenv("_SEPARATOR", "-------------------------------", 1);
  argz_create(environ, &amp;envz, &amp;len);
  argz_stringify(envz, len, '\n');
  envz[len-1]='\n';
  write(bug, envz, len);
  close(bug);
  free(envz);
  return 0;
}</literal>
EOF</userinput></screen>

      <para>Now compile it:</para>

<screen><userinput>gcc -o /lib/udev/bug bug.c</userinput></screen>

      <para>When booting the new LFS system, if any events are missed, a warning
      message will appear and a <filename>/dev/bugreport</filename> file will be
      created. The warning message will tell you where to send feedback.</para>

    </important>

  </sect2>

  <sect2 id="contents-udev" role="content">
    <title>Contents of Udev</title>

    <segmentedlist>
      <segtitle>Installed programs</segtitle>
      <segtitle>Installed directory</segtitle>

      <seglistitem>
        <seg>ata_id, cdrom_id, create_floppy_devices, edd_id, firmware_helper,
        path_id, scsi_id, udevcontrol, udevd, udevinfo, udevmonitor, udevsettle,
        udevtest, udevtrigger, usb_id, vol_id, and write_cd_aliases</seg>
        <seg>/etc/udev</seg>
      </seglistitem>
    </segmentedlist>

    <variablelist>
      <bridgehead renderas="sect3">Short Descriptions</bridgehead>
      <?dbfo list-presentation="list"?>
      <?dbhtml list-presentation="table"?>

      <varlistentry id="ata_id">
        <term><command>ata_id</command></term>
        <listitem>
          <para>Provides Udev with a unique string and
          additional information (uuid, label) for an ATA drive</para>
          <indexterm zone="ch-system-udev ata_id">
            <primary sortas="b-ata_id">ata_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="cdrom_id">
        <term><command>cdrom_id</command></term>
        <listitem>
          <para>Provides Udev with the capabilities of a
          CD-ROM or DVD-ROM drive</para>
          <indexterm zone="ch-system-udev cdrom_id">
            <primary sortas="b-cdrom_id">cdrom_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="create_floppy_devices">
        <term><command>create_floppy_devices</command></term>
        <listitem>
          <para>Creates all possible floppy devices based on the CMOS type</para>
          <indexterm zone="ch-system-udev create_floppy_devices">
            <primary sortas="b-create_floppy_devices">create_floppy_devices</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="edd_id">
        <term><command>edd_id</command></term>
        <listitem>
          <para>Provides Udev with the EDD ID for a BIOS disk drive</para>
          <indexterm zone="ch-system-udev edd_id">
            <primary sortas="b-edd_id">edd_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="firmware_helper">
        <term><command>firmware_helper</command></term>
        <listitem>
          <para>Uploads firmware to devices</para>
          <indexterm zone="ch-system-udev firmware_helper">
            <primary sortas="b-firmware_helper">firmware_helper</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="path_id">
        <term><command>path_id</command></term>
        <listitem>
          <para>Provide the shortest possible unique hardware path to a
          device</para>
          <indexterm zone="ch-system-udev path_id">
            <primary sortas="b-path_id">path_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="scsi_id">
        <term><command>scsi_id</command></term>
        <listitem>
          <para>Provides Udev with a unique SCSI identifier
          based on the data returned from sending a SCSI INQUIRY command to
          the specified device</para>
          <indexterm zone="ch-system-udev scsi_id">
            <primary sortas="b-scsi_id">scsi_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevcontrol">
        <term><command>udevcontrol</command></term>
        <listitem>
          <para>Configures a number of options for the running
          <command>udevd</command> daemon, such as the log level.</para>
          <indexterm zone="ch-system-udev udevcontrol">
            <primary sortas="b-udevcontrol">udevcontrol</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevd">
        <term><command>udevd</command></term>
        <listitem>
          <para>A daemon that listens for uevents on the netlink socket,
          creates devices and runs the configured external programs in
          response to these uevents</para>
          <indexterm zone="ch-system-udev udevd">
            <primary sortas="b-udevd">udevd</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevinfo">
        <term><command>udevinfo</command></term>
        <listitem>
          <para>Allows users to query the Udev database for
          information on any device currently present on the system; it also
          provides a way to query any device in the <systemitem
          class="filesystem">sysfs</systemitem> tree to help create udev
          rules</para>
          <indexterm zone="ch-system-udev udevinfo">
            <primary sortas="b-udevinfo">udevinfo</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevmonitor">
        <term><command>udevmonitor</command></term>
        <listitem>
          <para>Prints the event received from the kernel and the environment
          which Udev sends out after rule processing</para>
          <indexterm zone="ch-system-udev udevmonitor">
            <primary sortas="b-udevmonitor">udevmonitor</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevsettle">
        <term><command>udevsettle</command></term>
        <listitem>
          <para>Watches the Udev event queue and exits if all current uevents
          have been handled</para>
          <indexterm zone="ch-system-udev udevsettle">
            <primary sortas="b-udevsettle">udevsettle</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevtest">
        <term><command>udevtest</command></term>
        <listitem>
          <para>Simulates a uevent for the given device, and prints out the
          name of the node the real <command>udevd</command> would have created,
          or the name of the renamed network interface</para>
          <indexterm zone="ch-system-udev udevtest">
            <primary sortas="b-udevtest">udevtest</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="udevtrigger">
        <term><command>udevtrigger</command></term>
        <listitem>
          <para>Triggers kernel device uevents to be replayed</para>
          <indexterm zone="ch-system-udev udevtrigger">
            <primary sortas="b-udevtrigger">udevtrigger</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="usb_id">
        <term><command>usb_id</command></term>
        <listitem>
          <para>Provides Udev with information about USB
          devices</para>
          <indexterm zone="ch-system-udev usb_id">
            <primary sortas="b-usb_id">usb_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="vol_id">
        <term><command>vol_id</command></term>
        <listitem>
          <para>Provides Udev with the label and uuid of a
          filesystem</para>
          <indexterm zone="ch-system-udev vol_id">
            <primary sortas="b-vol_id">vol_id</primary>
          </indexterm>
        </listitem>
      </varlistentry>

      <varlistentry id="etc-udev">
        <term><filename class="directory">/etc/udev</filename></term>
        <listitem>
          <para>Contains Udev configuation files,
          device permissions, and rules for device naming</para>
          <indexterm zone="ch-system-udev etc-udev">
            <primary sortas="e-/etc/udev">/etc/udev</primary>
          </indexterm>
        </listitem>
      </varlistentry>

    </variablelist>

  </sect2>

</sect1>
