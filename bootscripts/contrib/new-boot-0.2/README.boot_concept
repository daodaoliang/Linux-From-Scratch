RUNLEVELS

This boot concept uses different runlevels. The runlevel determines how
many of the system's services are available.
Example:

  Checking file systems...                                [  OK  ]
  Remounting root file system in read-write mode...       [  OK  ]
  Adding swap space...                                    [  OK  ]
  Mounting local filesystems...                           [  OK  ]
  Loading /usr/share/keymaps/defkeymap.map                [  OK  ]
  Setting up hostname...                                  [  OK  ]
  Bringing up the loopback interface...                   [  OK  ]
  Initializing system clock from RTC...                   [  OK  ]
  Runlevel 1 reached!                                     [  OK  ] 

This could be the messages when booting into runlevel 1. If you boot
into runlevel 2, more services are started _in_addition_to_ those above:

  Clearing /var/lock/ and /var/run/ ...                   [  OK  ]
  Creating new /var/run/utmp...                           [  OK  ]
  Removing nologin, fastboot, forcefsck...                [  OK  ]
  Computing kernel module dependencies...                 [  OK  ]
  Speeding up /dev/hda...                                 [  OK  ]
  Runlevel 2 reached!                                     [  OK  ]

Every service is provided by a boot script. This is usually a shell script
but it could also be a perl script or even a compiled binary. The boot
script understands (at least) 2 parameters, "start" and "stop". When the
system is booted, the boot scripts are called with the "start" parameter and
they launch their respective services. During shutdown, the same scripts are
called with the "stop" parameter and they terminate their respective services.
There is no standard for which services are started in which runlevel but
the following can serve as a guideline for where to put your boot scripts:

Runlevel      Description
      
single        maintenance mode, no services started
runlevel 1    filesystems mounted, some essential setup but no daemons
runlevel 2    basic services, possibly including daemons, no network
runlevel 3    network support added 
runlevel 4    all available services, but still text login
runlevel 5    all available services, graphical login


RUNLEVEL DIRECTORIES

A runlevel is described by a directory called runlevel.? where ? is the number
of the runlevel. This directory contains the boot scripts that characterize
the runlevel. 

Look at the provided example directory structure for illustration.

It would be rather inconvenient to have copies of or links to
the same script in more than one runlevel directory and this is one major
difference of this system compared to the classic
sysvinit setups where the runlevel directories contain lots of symlinks.
Having every script exist in only one place makes maintenance easier 
and is not as fragile as symlinking it in several places. 
The symlink scheme can be avoided here because runlevels in this boot concept 
are real run _levels_, i.e. they
form a stack where every level builds on top of the previous level. In a 
sysvinit setup, the runlevels, in spite of their name, are actually independent 
run _configurations_, even though this flexibility (and complexity) is
seldom needed (or advisable). But don't worry, if you really need
independent configurations, you can still create them even if you use the
scheme described here, and it will always be cleaner than classic 
SysVinit setups.


INCLUDES AND ESSENTIAL SERVICES

If you look at the example directory tree you will see immediately how one
runlevel can extend another runlevel without containing a copy of every script.
An include marker is a 0-length file (usually created with the touch command)
that has the same name as either a runlevel directory or a
boot script. The include marker itself is not executable which distinguishes
it from a boot script. 

An include marker with the name of a runlevel directory includes all services 
from that directory. An include marker with the name
of a boot script includes only that script. Note that the included script may
be in any directory specified in INIT_PATH in /etc/inittab, so in this example
setup the actual script could be in init.d/ or any of the runlevel.? 
directories and it would always be found. So include markers are much more
convenient (and robust) than symlinks.

One thing that has not been mentioned yet, is the mysterious "+" that you
will find as the first character in the names of the include markers in the 
example directories. Include markers that begin with "+" mark services that
are *essential* to the runlevel. Because services are executed in alphabetical
order (so if you insist on controlling the boot-up sequence you can number
your services like you do for SysVinit installations), the "+" services are
started before the others in that runlevel. In addition to this, booting
a runlevel will stop if an essential service fails. This is useful when
a service is so important that it doesn't make sense to continue booting if
it fails. In the example setup for instance, if mounting filesystems fails,
runlevel 1 will not be reached and further runlevels will not even be
attempted. The superuser will have to fix the problem and then the command
"telinit 3" could be used to continue booting to runlevel 3.

Note that in the example setup the mountfs script and the include marker that
makes it essential are in the same directory. The script will *not* run twice,
though! If you don't like having an include marker and the included script in
the same directory just move the mountfs script out of the runlevel directory
into init.d/. It will work all the same. In fact you could even move the
mountfs script into runlevel.3 and there will be no difference. The script
will still be found and it won't run twice, even when going to runlevel 3.


DEPENDENCIES

You will notice that the boot scripts in this scheme are not numbered. This is
another simplification compared to SysVinit setups. 
It's actually much more than just a
simplification. Sysvinit installations require that the administrator specify
exactly the order in which boot scripts are to be executed. Getting this 
ordering right for a few scripts is not a big deal when you only do it once,
but often it is not that easy. 
A computer system is dynamic. You add services, remove services and replace 
services. There may be dozens of services that
could potentially be installed. Assigning sequence numbers properly in this
situation is difficult and error-prone. Moreover, it is not really what you
want. The actual ordering of services is not relevant as long as dependencies
are satisfied. This is the most important aspect of this boot concept. 

Boot scripts specify, using the "need" command, what they depend on, and init
will take care that the dependencies are met. Once every script is fitted
with the appropriate need statements, it is impossible to get the system into
an inconsistent state by moving, deleting or adding scripts, whereas a
SysVinit installation is easy to break by changing a single character in
the name of a single symlink.
Additionally, if a service fails to start up properly, then services that
depend on it are not started either. The sequence numbers in a SysVinit 
installation fail utterly in this respect.


SUSPENDING SERVICES

Even though the stack principle works most of the time, sometimes you might 
want to have a service in a lower runlevel that you don't
want in a higher runlevel, e.g. there might be a console
mouse driver that interferes with the X Window System. The proper way to deal
with this situation is to create a suspend_service script that, when called
with the "start" parameter will suspend (if the service has a suspend command)
or stop the service and will resume or restart the service when called with
the "stop" parameter. This suspend_service script is then put into the 
runlevel where the service is not desirable. This solution may seem clumsy but
services that require this treatment are so few that this is the easiest
solution. Of course if you really wanted to you could use the brute force
method of creating a runlevel that does not have an include marker for a 
previous runlevel but only include markers for the necessary scripts. This
would create an independent boot configuration as used in SysVinit setups
(but still more elegant).


RUNLEVEL AND SERVICE MANAGEMENT

Simpleinit provides a service management scheme that allows you to
easily view the status of services with the display-services command
Example:

  ~/> display-services

  AVAILABLE SERVICES:
  runlevel.3
  ethernet
  runlevel.2
  logging
  depmod
  cleanfs
  runlevel.1
  setclock
  localnet
  loadkeys
  mountfs
  checkfs
  STARTING SERVICES:
  UNAVAILABLE SERVICES:
  hdparm (FAILED)

This is a display of the service stack. You can use the initctl(8) command to
test for, start and stop services. See the initctl(8) manpage for details.
Usually, however, you would not use initctl(8) directly to control services.
initctl(8) is mostly used in boot scripts (called as "need" in this context)
but the system as a whole is controlled via telinit(8). The telinit command
communicates with the runlevel control script "rc" and tells it to change
runlevels. 

telinit(8) is easy to use:

telinit help		displays telinit usage

telinit <num>
  or           
telinit runlevel.<num>  will go up or down to runlevel <num>

telinit single          will bring the system to maintenance mode 

telinit <service> <params> 
			will call <service> with arguments <params>,
			e.g. telinit logging status
			You should prefer this method over calling boot
			scripts directly because telinit makes sure the
			environment is set up similar to that created by init
			when it starts boot scripts.
			
			NOTE: If you call 
			        telinit <service> start
			      or 
			        telinit <service> stop
			      you will bypass the dependency management system,
			      i.e. the script will be started or stopped 
			      without init knowing about it. 
			      Read initctl(8) to understand all the 
			      implications of this.
			 

ATTENTION! 
You can *not* use the command "init <num>" instead of "telinit <num>" to go to
runlevel <num>. This would instead launch a user space init (see below) that
would try to simulate booting into runlevel <num>.


LOCATION INDEPENDENCE AND USER SPACE EXECUTION

It is often hard to test a boot script setup because this usually requires
booting over and over again. Not so with Simpleinit-msb. It is possible
to start the exact same setup when logged in as an ordinary user. This is
extremely useful when you're building up a system from scratch and want to
test the boot script setup before booting into the new system, or when you 
make larger changes to your setup. It also enables you to check out the 
features of Simpleinit-msb without endangering your main installation.
You can test it while keeping a SysVinit installation as your boot setup and
if you don't like Simpleinit-msb you can just delete it. And if you do
like it you just copy the setup from your test directory to the appropriate
directory and install Simpleinit-msb.

This is how user space init works:

1. Simpleinit-msb sets the INIT_D environment variable to tell scripts
   the directory where the runlevel.? directories are found. 
   Another useful environment variable is INIT_ROOT, which is empty for
   the main system init but contains the virtual root directory of the user
   space init. This allows scripts to refer to $INIT_ROOT/etc/inittab for
   instance.
   
   Using these environment variables, boot scripts can be written completely
   location independent. The example scripts demonstrate this. I use these
   exact same scripts unchanged for my main installation.
   
   NOTE: It is recommended (although not strictly necessary) you include
   a fallback path in your boot scripts for the case that $INIT_D is not
   set. One way to do this is to write something like ${INIT_D:-/sbin/init.d} 
   instead of just $INIT_D.
   This makes sure that the boot script will work, even if INIT_D is not 
   present. The script can thus be used with other inits or called 
   directly (calling via telinit will always work because telinit sets $INIT_D)
   Unfortunately there is no agreement on the location of boot scripts.
   The example uses /sbin/init.d but other popular directories are
   /etc/init.d and /etc/rc.d. If you are writing scripts only for yourself,
   hardwiring your favorite path will work fine but if you write scripts
   for a broader audience, you should support different locations.
   The example scripts have been written with this in mind. They work in
   all three locations, so if you don't like /sbin/init.d, you can use the
   scripts unchanged in /etc/init.d or /etc/rc.d. The only thing you have to
   change is the "fileprefix=" line in /etc/inittab.
   
2. You can set a PATH in /etc/inittab that boot scripts will use. This way
   your boot scripts do not have to (and should not) use absolute pathnames 
   like "/sbin/mount".
   Note that the example scripts include a PATH= statement in functions, 
   even though Simpleinit sets the path. 
   This is to make the scripts compatible with other inits 
   (see README.compatibility).

3. User space init sets the USERSPACE_INIT environment variable. Boot scripts
   can test for this variable and act accordingly. 
   In the example boot scripts, the functions script uses this variable to 
   decide if it should source the sim-bins script. This script defines shell 
   functions that 
   simulate (usually by just returning exit code 0) binaries that should not
   be executed in user space (like mount). Because (see 2.) full pathnames are
   avoided in the scripts, these shell functions hide the real binaries, 
   allowing the testing of boot scripts that use privileged commands in 
   user space.

4. The INIT_PATH entry in /etc/inittab contains a path that is searched for
   boot scripts when a need command is issued. This makes need(8) location
   independent. Relative path entries in INIT_PATH are appended to fileprefix,
   i.e. they are relative to $INIT_D/

5. Files with paths hardwired into Simpleinit (e.g. /etc/inittab) are
   interpreted relative to $INIT_ROOT by a user space init. This makes
   user space testing completely independent from the main installation, which
   does not even have to be Simpleinit-based.


EXAMPLE FILES

Some of the provided example files need special explanation:

functions: This file contains functions used by all boot scripts, most 
notably the functions to write the fancy colored [  OK  ] and [FAILED]
status. 

services: In order to make the setup more robust against changes, the
services file which is sourced by the functions script assigns service
names to scripts for the use in need commands. 
This increases maintainability when boot script names change, because it
removes the need to adjust dependencies.


Example: need apache
	 will break if the apache script is replaced with a khttpd script
	 but
	 need $http_daemon
	 will continue working as long as you change
	 http_daemon=apache to http_daemon=khttpd in the services file
Other solutions are possible, of course. You could also use
"need http_daemon" and create a symlink of that name to whichever script is
currently providing the service. If you do this, you can do without the
services file.

services is also used to hide the paths of configuration files from the boot
scripts. This is useful for instance if you want to use the provided scripts
on a standard LFS system that uses lots of small files in /etc/sysconfig/
rather than 1 file $INIT_D/sysconfig. You only change the services file.
	 
sim-bins: For user space testing, this file is sourced in functions when
init is run in user space. It defines shell functions that replace binaries 
like mount that you don't want to/can not call in user space.

sysconfig: This file is sourced by some boot scripts. It contains settings
that should not be hardwired in boot scripts, like the hostname for instance.
sysconfig is never sourced directly but only via the alias names from the
services file. That way you can place it wherever you want it and even
split it up into small files (as LFS does it) without having to change the
actual boot scripts.


BOOT SCRIPT GUIDELINES

It is important that you read the BOOT SCRIPT GUIDELINES section in 
initctl(8), because boot scripts have to meet certain conditions for the
service management to function correctly. To summarize for the impatient:
Every script needs to understand the arguments "start" and "stop".
If called with argument "start", the service is to be started. In that
case the script *must* return exit code 0 if the service has been started
and *must* return non-zero if it has not.
If called with the "stop" argument, the service is to be stopped. In this
case the script *must* return exit code 0 if the service 
_has_been_disabled_or_was_not_working_in_the_first_place.
Read the last sentence carefully. This means that if the stop script 
detects that the service is broken, it must return 0. It may sound strange
at first but it makes sense. If a service is broken it is not available 
anymore and that is exactly what the stop script was called to achieve.
Note that even services that don't need to be stopped such as checking
filesystems must support the "stop" parameter and return 0.


TESTING AND INSTALLING BOOT SCRIPTS

Whenever you make major changes to your boot script setup, you should do 
the following:

1. Test setup in user space (see LOCATION INDEPENDENCE AND USER SPACE 
   EXECUTION above and read the README.testing file) 
   with all binaries simulated via sim-bins (see EXAMPLE FILES above).
   
2. If everything works, move the new setup to the final location 
   and change inittab if necessary. Don't forget to set the ctrlaltdel= entry 
   if you had a special one for user space init.
