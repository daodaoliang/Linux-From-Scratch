<chapter id="chapter-temporary-tools" xreflabel="Chapter 5">
<title>Constructing a temporary system</title>
<?dbhtml filename="chapter05.html" dir="chapter05"?>


<sect1 id="ch-tools-introduction">
<title>Introduction</title>
<?dbhtml filename="introduction.html" dir="chapter05"?>

<para>In this chapter we will compile and install a minimal
Linux system. This system will contain just enough tools to be able
to start constructing the final LFS system in the next chapter.</para>

<para>The building of this minimal system is done in two steps: first we
build a brand-new and host-independent toolchain (compiler, assembler,
linker and libraries), and then use this to build all the other essential
tools.</para>

<para>The files compiled in this chapter will be installed under the
<filename class="directory">$LFS/tools</filename> directory
to keep them separate from the files installed in the next chapter.
Since the packages compiled here are merely temporary, we don't want
them to pollute the soon-to-be LFS system.</para>

<para>Before issuing the build instructions for a package you are expected to
have already unpacked it as user <emphasis>lfs</emphasis>, and to have
performed a <userinput>cd</userinput> into the created directory. The build
instructions assume that you are using the <command>bash</command>
shell.</para>

<para>Several of the packages are patched before compilation, but only when
the patch is needed to circumvent a problem. Often the patch is needed in
both this and the next chapter, but sometimes in only one of them. Therefore,
don't worry when instructions for a downloaded patch seem to be missing. Also,
when applying a patch, you'll occasionally see warning messages about
<emphasis>offset</emphasis> or <emphasis>fuzz</emphasis>. These warnings are
nothing to worry about, as the patch was still successfully applied.</para>

<para>During the compilation of most packages you will see many warnings
scroll by on your screen. These are normal and can safely be ignored. They are
just what they say they are: warnings -- mostly about deprecated, but not
invalid, use of the C or C++ syntax. It's just that C standards have changed
rather often and some packages still use the older standard, which is not
really a problem.</para>

<para>After installing each package you should delete its source and build
directories, <emphasis>unless</emphasis> told otherwise. Deleting the sources
saves space, but also prevents misconfiguration when the same package is
reinstalled further on. Only for three packages you will need to keep the
source and build directories around for a while, so their contents can be used
by later commands. Do not miss the reminders.</para>

</sect1>


<sect1 id="tools-technicalnotes">
<title>Technical notes</title>
<?dbhtml filename="technicalnotes.html" dir="chapter05"?>

<para>This section attempts to explain some of the rationale and technical
details behind the overall build method. It's not essential that you understand
everything here immediately. Most of it will make sense once you have performed
an actual build. Feel free to refer back here at any time.</para>

<para>The overall goal of <xref linkend="chapter-temporary-tools"/> is to provide a sane,
temporary environment that we can chroot into, and from which we can produce a
clean, trouble-free build of the target LFS system in
<xref linkend="chapter-building-system"/>. Along the way, we attempt to divorce ourselves
from the host system as much as possible, and in so doing build a
self-contained and self-hosted toolchain. It should be noted that the
build process has been designed in such a way so as to minimize the risks for
new readers and provide maximum educational value at the same time. In other
words, more advanced techniques could be used to build the system.</para>

<important>
<para>Before continuing, you really should be aware of the name of your working
platform, often also referred to as the <emphasis>target triplet</emphasis>. For
many folks the target triplet will probably be
<emphasis>i686-pc-linux-gnu</emphasis>. A simple way to determine your target
triplet is to run the <filename>config.guess</filename> script that comes with
the source for many packages. Unpack the Binutils sources and run the script:
<userinput>./config.guess</userinput> and note the output.</para>

<para>You'll also need to be aware of the name of your platform's
<emphasis>dynamic linker</emphasis>, often also referred to as the
<emphasis>dynamic loader</emphasis>, not to be confused with the standard linker
<emphasis>ld</emphasis> that is part of Binutils. The dynamic linker is provided
by Glibc and has the job of finding and loading the shared libraries needed by a
program, preparing the program to run and then running it. For most folks the
name of the dynamic linker will be <emphasis>ld-linux.so.2</emphasis>. On
platforms that are less prevalent, the name might be
<emphasis>ld.so.1</emphasis> and newer 64 bit platforms might even have
something completely different. You should be able to determine the name
of your platform's dynamic linker by looking in the
<filename class="directory">/lib</filename> directory on your host system. A
surefire way is to inspect a random binary from your host system by running:
<userinput>readelf -l &lt;name of binary&gt; | grep interpreter</userinput>
and noting the output. The authoritative reference covering all platforms is in
the <filename>shlib-versions</filename> file in the root of the Glibc source
tree.</para>
</important>

<para>Some key technical points of how the <xref linkend="chapter-temporary-tools"/> build
method works:</para>

<itemizedlist>
<listitem><para>Similar in principle to cross compiling whereby tools installed
into the same prefix work in cooperation and thus utilize a little GNU
"magic".</para></listitem>

<listitem><para>Careful manipulation of the standard linker's library search
path to ensure programs are linked only against libraries we
choose.</para></listitem>

<listitem><para>Careful manipulation of <command>gcc</command>'s
<emphasis>specs</emphasis> file to tell the compiler which target dynamic
linker will be used.</para></listitem>
</itemizedlist>

<para>Binutils is installed first because both GCC and Glibc perform various
feature tests on the assembler and linker during their respective runs of
<command>./configure</command> to determine which software features to enable
or disable. This is more important than one might first realize. An incorrectly
configured GCC or Glibc can result in a subtly broken toolchain where the impact
of such breakage might not show up until near the end of the build of a whole
distribution. Thankfully, a test suite failure will usually alert us before too
much time is wasted.</para>

<para>Binutils installs its assembler and linker into two locations,
<filename class="directory">/tools/bin</filename> and
<filename class="directory">/tools/$TARGET_TRIPLET/bin</filename>. In reality,
the tools in one location are hard linked to the other. An important facet of
the linker is its library search order. Detailed information can be obtained
from <command>ld</command> by passing it the <emphasis>--verbose</emphasis>
flag. For example: <command>ld --verbose | grep SEARCH</command> will
show you the current search paths and their order. You can see what files are
actually linked by <command>ld</command> by compiling a dummy program and
passing the <emphasis>--verbose</emphasis> switch to the linker. For example:
<command>gcc dummy.c -Wl,--verbose 2>&amp;1 | grep succeeded</command>
will show you all the files successfully opened during the linking.</para>

<para>The next package installed is GCC and during its run of
<command>./configure</command> you'll see, for example:</para>

<blockquote><screen>checking what assembler to use... /tools/i686-pc-linux-gnu/bin/as
checking what linker to use... /tools/i686-pc-linux-gnu/bin/ld</screen></blockquote>

<para>This is important for the reasons mentioned above. It also demonstrates
that GCC's configure script does not search the PATH directories to find which
tools to use. However, during the actual operation of <command>gcc</command>
itself, the same search paths are not necessarily used. You can find out which
standard linker <command>gcc</command> will use by running:
<command>gcc -print-prog-name=ld</command>.
Detailed information can be obtained from <command>gcc</command> by passing
it the <emphasis>-v</emphasis> flag while compiling a dummy program. For
example: <command>gcc -v dummy.c</command> will show you detailed
information about the preprocessor, compilation and assembly stages, including
<command>gcc</command>'s include search paths and their order.</para>
 
<para>The next package installed is Glibc. The most important considerations for
building Glibc are the compiler, binary tools and kernel headers. The compiler
is generally no problem as Glibc will always use the <command>gcc</command>
found in a PATH directory. The binary tools and kernel headers can be a little
more troublesome. Therefore we take no risks and use the available configure
switches to enforce the correct selections. After the run of
<command>./configure</command> you can check the contents of the
<filename>config.make</filename> file in the
<filename class="directory">glibc-build</filename> directory for all the
important details. You'll note some interesting items like the use of
<emphasis>CC="gcc -B/tools/bin/"</emphasis> to control which binary tools are
used, and also the use of the <emphasis>-nostdinc</emphasis> and
<emphasis>-isystem</emphasis> flags to control the compiler's include search
path. These items help to highlight an important aspect of the Glibc package:
it is very self-sufficient in terms of its build machinery and generally does
not rely on toolchain defaults.</para>

<para>After the Glibc installation, we make some adjustments to ensure that
searching and linking take place only within our <filename>/tools</filename>
prefix. We install an adjusted <command>ld</command>, which has a hard-wired
search path limited to <filename class="directory">/tools/lib</filename>. Then
we amend <command>gcc</command>'s specs file to point to our new dynamic
linker in <filename class="directory">/tools/lib</filename>. This last step is
<emphasis>vital</emphasis> to the whole process. As mentioned above, a
hard-wired path to a dynamic linker is embedded into every ELF shared
executable. You can inspect this by running:
<command>readelf -l &lt;name of binary&gt; | grep interpreter</command>.
By amending <command>gcc</command>'s specs file, we are ensuring that every
program compiled from here through the end of this chapter will use our new
dynamic linker in <filename class="directory">/tools/lib</filename>.</para>

<para>The need to use the new dynamic linker is also the reason why we apply the
Specs patch for the second pass of GCC. Failure to do so will result in the GCC
programs themselves having the name of the dynamic linker from the host system's
<filename class="directory">/lib</filename> directory embedded into them, which
would defeat our goal of getting away from the host.</para>

<para>During the second pass of Binutils, we are able to utilize the
<emphasis>--with-lib-path</emphasis> configure switch to control
<command>ld</command>'s library search path. From this point onwards, the
core toolchain is self-contained and self-hosted. The remainder of the
<xref linkend="chapter-temporary-tools"/> packages all build against the new Glibc in
<filename class="directory">/tools</filename> and all is well.</para>

<para>Upon entering the chroot environment in <xref linkend="chapter-building-system"/>, the
first major package we install is Glibc, due to its self-sufficient nature that
we mentioned above. Once this Glibc is installed into
<filename class="directory">/usr</filename>, we perform a quick changeover of
the toolchain defaults, then proceed for real in building the rest of the
target LFS system.</para>

</sect1>


<sect1 id="tools-aboutlinking">
<title>Notes on static linking</title>
<?dbhtml filename="aboutlinking.html" dir="chapter05"?>

<para>Most programs have to perform, beside their specific task, many rather
common and sometimes trivial operations. These include allocating memory,
searching directories, reading and writing files, string handling, pattern
matching, arithmetic and many other tasks. Instead of obliging each program to
reinvent the wheel, the GNU system provides all these basic functions in
ready-made libraries. The major library on any Linux system is
<emphasis>Glibc</emphasis>.</para>

<para>There are two primary ways of linking the functions from a library to a
program that uses them: statically or dynamically. When a program is linked
statically, the code of the used functions is included in the executable,
resulting in a rather bulky program. When a program is dynamically linked, what
is included is a reference to the dynamic linker, the name of the library, and
the name of the function, resulting in a much smaller executable. (A third way
is to use the programming interface of the dynamic linker. See the
<emphasis>dlopen</emphasis> man page for more information.)</para>

<para>Dynamic linking is the default on Linux and has three major advantages
over static linking. First, you need only one copy of the executable library
code on your hard disk, instead of having many copies of the same code included
into a whole bunch of programs -- thus saving disk space. Second, when several
programs use the same library function at the same time, only one copy of the
function's code is required in core -- thus saving memory space. Third, when a
library function gets a bug fixed or is otherwise improved, you only need to
recompile this one library, instead of having to recompile all the programs that
make use of the improved function.</para>

<para>If dynamic linking has several advantages, why then do we statically link
the first two packages in this chapter? The reasons are threefold: historical,
educational, and technical. Historical, because earlier versions of LFS
statically linked every program in this chapter. Educational, because knowing
the difference is useful. Technical, because we gain an element of independence
from the host in doing so, meaning that those programs can be used
independently of the host system. However, it's worth noting that an overall
successful LFS build can still be achieved when the first two packages are
built dynamically.</para>

</sect1>


&c5-binutils-pass1;
&c5-gcc-pass1;
&c5-kernelheaders;
&c5-glibc;


<sect1 id="ch-tools-adjusting">
<title>Adjusting the toolchain</title>
<?dbhtml filename="adjusting.html" dir="chapter05"?>

<para>Now that the temporary C libraries have been installed, we want all
the tools compiled in the rest of this chapter to be linked against these
libraries. To accomplish this, we need to adjust the linker and the compiler's
specs file. Some people would say that it is <emphasis>"black magic juju below
this line"</emphasis>, but it is really very simple.</para>

<para>First install the adjusted linker (adjusted at the end of the first pass
of Binutils) by running the following command from within
the <filename class="directory">binutils-build</filename> directory:</para>

<screen><userinput>make -C ld install</userinput></screen>

<para>From this point onwards everything will link <emphasis>only</emphasis>
against the libraries in <filename>/tools/lib</filename>.</para>

<note><para>If you somehow missed the earlier warning to retain the Binutils
source and build directories from the first pass or otherwise accidentally
deleted them or just don't have access to them, don't worry, all is not lost.
Just ignore the above command. The result is a small chance of the subsequent
testing programs linking against libraries on the host. This is not ideal, but
it's not a major problem. The situation is corrected when we install the
second pass of Binutils a bit further on.</para></note>

<para>Now that the adjusted linker is installed, you have to
<emphasis>remove</emphasis> the Binutils build and source directories.</para>

<para>The next thing to do is to amend our GCC specs file so that it points
to the new dynamic linker. A simple sed will accomplish this:</para>

<!-- Ampersands are needed to allow cut and paste -->

<screen><userinput>SPECFILE=/tools/lib/gcc-lib/*/*/specs &amp;&amp;
sed -e 's@ /lib/ld-linux.so.2@ /tools/lib/ld-linux.so.2@g' \
&nbsp;&nbsp;&nbsp;&nbsp;$SPECFILE &gt; tempspecfile &amp;&amp;
mv -f tempspecfile $SPECFILE &amp;&amp;
unset SPECFILE</userinput></screen>

<para>We recommend that you cut-and-paste the above rather than try and type it
all in. Or you can edit the specs file by hand if you want to: just replace the
occurrence of "/lib/ld-linux.so.2" with "/tools/lib/ld-linux.so.2". Be sure to
visually inspect the specs file to verify the intended change was actually
made.</para>

<important><para>If you are working on a platform where the name of the dynamic
linker is something other than <filename>ld-linux.so.2</filename>, you
<emphasis>must</emphasis> substitute <filename>ld-linux.so.2</filename> with the
name of your platform's dynamic linker in the above commands. Refer back to
<xref linkend="tools-technicalnotes"/> if necessary.</para></important>

<para>Lastly, there is a possibility that some include files from the host
system have found their way into GCC's private include dir. This can happen
because of GCC's "fixincludes" process which runs as part of the GCC build.
We'll explain more about this further on in this chapter. For now, run the
following commands to eliminate this possibility:</para>

<screen><userinput>rm -f /tools/lib/gcc-lib/*/*/include/{pthread.h,bits/sigthread.h}</userinput></screen>

<!-- HACK - Force some whitespace to appease tidy -->
<literallayout></literallayout>

<caution><para>It is imperative at this point to stop and ensure that the basic
functions (compiling and linking) of the new toolchain are working as expected.
For this we are going to perform a simple sanity check:</para>

<screen><userinput>echo 'main(){}' &gt; dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'</userinput></screen>

<para>If everything is working correctly, there should be no errors, and the
output of the last command will be (allowing for platform specific differences
in dynamic linker name):</para>

<blockquote><screen>[Requesting program interpreter: /tools/lib/ld-linux.so.2]</screen></blockquote>

<para>Note especially that <filename class="directory">/tools/lib</filename>
appears as the prefix of our dynamic linker.</para>

<para>If you did not receive the output
as shown above, or received no output at all, then something is seriously wrong.
You will need to investigate and retrace your steps to find out where the
problem is and correct it. There is no point in continuing until this is done.
First, redo the sanity check using <command>gcc</command> instead of
<command>cc</command>. If this works it means the
<filename class="symlink">/tools/bin/cc</filename> symlink is missing. Revisit
<xref linkend="ch-tools-gcc-pass1"/> and fix the symlink. Second, ensure your PATH
is correct. You can check this by running <userinput>echo $PATH</userinput> and
verifying that <filename class="directory">/tools/bin</filename> is at the head
of the list. If the PATH is wrong it could mean you're not logged in as user
<emphasis>lfs</emphasis> or something went wrong back in <xref
linkend="prepare-settingenvironment"/>. Third, something may have gone wrong
with the specs file amendment above. In this case redo the specs file amendment
ensuring to cut-and-paste the commands as was recommended.</para>

<para>Once you are satisfied that all is well, clean up the test files:</para>

<screen><userinput>rm dummy.c a.out</userinput></screen>
</caution>

<!-- HACK - Force some whitespace to appease tidy -->
<literallayout></literallayout>

</sect1>


&c5-tcl;
&c5-expect;
&c5-dejagnu;
&c5-gcc-pass2;
&c5-binutils-pass2;

&c5-gawk;
&c5-coreutils;
&c5-bzip2;
&c5-gzip;
&c5-diffutils;
&c5-findutils;
&c5-make;
&c5-grep;
&c5-sed;
&c5-gettext;
&c5-ncurses;
&c5-patch;
&c5-tar;
&c5-texinfo;
&c5-bash;
&c5-perl;


<sect1 id="ch-tools-stripping">
<title>Stripping</title>
<?dbhtml filename="stripping.html" dir="chapter05"?>

<para>The steps in this section are optional, but if your LFS partition is
rather small, you will be glad to learn that you can remove some unnecessary
things. The executables and libraries you have built so far contain about 130
MB of unneeded debugging symbols. Remove those symbols with:</para>

<screen><userinput>strip --strip-debug /tools/lib/*
strip --strip-unneeded /tools/{,s}bin/*</userinput></screen>

<para>The last of the above commands will skip some twenty files, reporting
that it doesn't recognize their file format. Most of them are scripts instead
of binaries.</para>

<para>Take care <emphasis>not</emphasis> to use
<emphasis>--strip-unneeded</emphasis> on the libraries -- the static ones
would be destroyed and you would have to build the three toolchain packages
all over again.</para>

<para>To save another 30 MB, you can remove all the documentation:</para>

<screen><userinput>rm -rf /tools/{doc,info,man}</userinput></screen>

<para>You will now need to have at least 850 MB of free space on your LFS
file system to be able to build and install Glibc in the next phase. If you can
build and install Glibc, you can build and install the rest too.</para>

</sect1>

</chapter>

