#!/bin/sh
# Begin $rc_base/init.d/functions - Run Level Control Functions

# Based on functions script from LFS-3.1 and earlier.
# Rewritten by Gerard Beekmans  - gerard@linuxfromscratch.org

# With code based on Matthias Benkmann's simpleinit-msb @
# http://winterdrache.de/linux/newboot/index.html

# Environmental setup
# Setup default values for environment
umask 022
export PATH="/bin:/usr/bin:/sbin:/usr/sbin"

# Default values for kill function
# Initial Stop Signal
STOPSIG="TERM"

# Fallback if STOPSIG does not stop a process in time (see KILLDELAY)
FALLBACK="KILL"

# Signal sent to running processes to refresh their configuration
RELOADSIG="HUP"

# Number of seconds between STOPSIG and FALLBACK when stopping processes
KILLDELAY="3"
PIDFILE=""

# Screen Dimentions
if [ -z "${COLUMNS}" ]
then
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]
then 
	COLUMNS=80
fi

# Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

# Set Cursur Position Commands, used via echo -e
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char

# Set color commands, used via echo -e
# Please consult `man console_codes for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning, when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
INFO="\\033[1;36m"           # Information is light cyan
BRACKET="\\033[1;34m"        # Brackets are blue

BOOTMESG_PREFIX=" * "        # Text at the beginning of every line

# Set screen and bootlog message values to ero
BOOTMESG=""                  # buffer for text meant for the logfile
BOOTMESGCON=""               # buffer for text meant for the console
BOOTSERVICE=""

#*******************************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $1 is the message
#               $2 is the colorcode for the console
#
# Outputs:      Standard Output
#
# Dependencies: - sed for parsing strings.
#		- grep, for counting \n's in a variable.
#               - $WCOL, for max line length, from functions.
#
# Todo:         - This function was created for the purpose of storing
#               information to be passed to a bootup log.  The logging support
#               is not yet added.  Support for possible parallel bootscripts is
#		also not added yet.
#		- Need to take a closer look at the internal do loop.
#*******************************************************************************
boot_mesg()
{
	# First call to boot_mesg, set BOOTMESG normally
	if [ -z "${BOOTMESG}" ]
	then
		BOOTMESG="${1}"
		# the color codes in ${2} could get messed up if not separated
		BOOTMESGCON=" \b${2} \b${BOOTMESG_PREFIX}${1}"

	# Subsequent calls will overwrite the text already on the screen
	# with replacement text by counting the lines in the last BOOTMESG
	# and calling CURS_UP that many times
	# It will also append our new text onto the BOOTMESG variable

	else
		local length=`echo -e "${BOOTMESGCON}" | sed -n -e "s/\$/\n/g;L ${WCOL}" | grep -c \$`
		local count=0
		local i=0
		BOOTMESG="${BOOTMESG}${1}"
		# the color codes in ${2} could get messed up if not separated
		BOOTMESGCON="${BOOTMESGCON} \b${2} \b${1}"
		while [ "${count}" -lt "${length}" ]
		do
			echo -n -e "${CURS_UP}"
				# This extra loop needs to be looked at
				# more closely.  It is used to write
				# spaces before we write the message
				# because somtimes the message does not
				# get wrapped the first time, but does
				# the second and leaves double words and
				# other such annoyances.
				while [ "${i}" -le "${WCOL}" ]
				do
					echo -n " "
					i=$((${i}+1))
				done
			echo
			echo -n -e "${CURS_UP}"
			count=$((${count}+1))
		done
	fi

	# This will wrap BOOTMESG to a maximum of $WCOL characters
	echo -e "${BOOTMESGCON}" | sed -n -e "s/\$/\n/g;L ${WCOL}"
}

boot_mesg_flush()
{
	# Do not log null messages
	if [ -z "${BOOTMESG}" ]
	then
		return 0
	fi

	if [ -z "${BOOTSERVICE}" ]
	then
		boot_log "${BOOTMESG}""${@}"
	else
		boot_log "${BOOTSERVICE}""${@}"
	fi
	
	# Reset BOOTMESG and BOOTMESGCON to keep from bleeding over again
	BOOTMESG=""
	BOOTMESGCON=""
}

boot_log()
{
	/bin/logger -p local0.info -t bootlog "${@}"
}

echo_ok()
{
	echo -n -e "${CURS_UP}""${SET_COL}"
	echo -n -e "${BRACKET}""[""${SUCCESS}""  OK  ""${BRACKET}""]"
	echo -e "${NORMAL}"
	boot_mesg_flush "[  OK  ]"
}

echo_failure()
{
	echo -n -e "${CURS_UP}""${SET_COL}"
	echo -n -e "${BRACKET}""[""${FAILURE}"" FAIL ""${BRACKET}""]"
	echo -e "${NORMAL}"
	boot_mesg_flush "[ FAIL ]"
}

echo_warning()
{
	echo -n -e "${CURS_UP}""${SET_COL}"
	echo -n -e "${BRACKET}""[""${WARNING}"" WARN ""${BRACKET}""]"
	echo -e "${NORMAL}"
	boot_mesg_flush "[ WARN ]"
}

print_error_msg()
{
	# $i is inherited by the rc script
	boot_log "${i} failed and exited with a return value of ${error_value}."
	boot_mesg "FAILURE:\n\nYou should not be reading this error" ${FAILURE}
	boot_mesg " message.  It means that an unforseen error took"
	boot_mesg " place in ${i}, which exited with a return value of"
	boot_mesg " ${error_value}.\n\nIf you're able to track this"
	boot_mesg " error down to a bug in one of the files provided by"
	boot_mesg " the LFS book, please be so kind to inform us at"
	boot_mesg " lfs-dev@linuxfromscratch.org."
	boot_mesg "\n\nPress Enter to continue..." ${INFO}
	boot_mesg "" ${NORMAL}
	# Reset BOOTMESG and BOOTMESGCON to keep from bleeding over again
	BOOTMESG=""
	BOOTMESGCON=""
	read ENTER
}

check_script_status()
{
	# $i is inherited by the rc script
	if [ ! -f ${i} ]
	then
		boot_mesg "${i} is not a valid symlink." ${WARNING}
		echo_warning
		continue
	fi

	if [ ! -x ${i} ]
	then
		boot_mesg "${i} is not executable, skipping." ${WARNING}
		echo_warning
		continue
	fi
}

evaluate_retval()
{
	error_value="${?}"

	if [ ${error_value} = 0 ]
	then
		echo_ok
	else
		echo_failure
		sleep 5 # To be removed upon completion of logging abilities
	fi

	# This prevents the 'An Unexpected Error Has Occurred' from trivial
	# errors.
	return 0
}

print_status()
{
	if [ "${#}" = "0" ]
	then
		echo "Usage: ${0} {success|warning|failure}"
		return 1
	fi

	boot_mesg_flush
	boot_mesg "NOTE: The use of print_status() is deprecated." ${WARNING}
	echo_warning

	case "${1}" in

		success)
			echo_ok
			;;

		warning)
			# Leave this extra case in becasue old scripts
			# may call it this way.
			case "${2}" in
				running)
					boot_mesg "Already running." ${WARNING}
					echo_warning
					;;
				not_running)
					boot_mesg "Not running." ${WARNING}
					echo_warning
					;;
				not_available)
					boot_mesg "Not available." ${WARNING}
					echo_warning
					;;
				*)
					# This is how it is supposed to
					# be called
					echo_warning
					;;
			esac
		;;

		failure)
			echo_failure
		;;

	esac

}

# Returns all of the pid #'s for $1 process
getpids()
{
	# Setup Environment
	local lpids=""
	local pid=""
	pidlist=""
	nopid=""

	# If PIDFILE is set, then we get our pidlist from there
	if [ -n "${PIDFILE}" ]
	then
		lpids="$(cat ${PIDFILE} 2>/dev/null)"
		if [ "${?}" = "0" ]
		then
			# Sometimes we may have a stale PIDFILE, verify that all
			# pids are valid
			for pid in ${lpids}
			do
				kill -0 ${pid} 2>/dev/null && pidlist="${pidlist} ${pid}"
			done

			if [ -z "${pidlist}" ]
			then
				nopid="0"
			else
				nopid="1"
			fi
		else
			nopid="0"
		fi
	# Else, we get our pidlist from pidof
	else
		# Strip any thing after the program name so we know what
		# name to throw at pidof
		base="${1##*/}"
		local pid=""
		local lpids=""

		lpids=$(pidof ${base})
		# Use the return value of pidof above
		# if the list is empty then we are not running and
		# the return value is 1, else nopid is false
		if [ "${?}" = "0" ]
		then
			nopid="1"
			for pid in ${lpids}
			do
				if [ "${pid}" -ne "$$" -a "${pid}" -ne "${PPID}" ]
				then 
					pidlist="${pidlist} ${pid}"
				fi
			done
		else
			nopid="0"
		fi
	fi
}

# Starts a program if it is currently not running
loadproc()
{
	if [ "${#}" = "0" ]
	then
		echo "Usage: loadproc {program} [-nomsg]"
		exit 1
	fi

	getpids "${1}"

	if [ "${nopid}" = "0" ]
	then
		"${@}"
		evaluate_retval
		if [ "${2}" != "-nomsg" ]
		then
			evaluate_retval
		fi
	else
		if [ "${2}" != "-nomsg" ]
		then
			boot_mesg "Process ${2} not running." ${WARNING}
			echo_warning
		fi
	fi
}

# Stops a process if it is running
killproc()
{
	if [ -z "${PIDFILE}" -a -z "${#}" ]
	then
		echo "Usage: killproc [{program}] [-nomsg]"
		exit 1	
	fi

	getpids "${1}"

	# Send the SIGSTOP to the running process list
	if [ -n "${pidlist}" ]
	then
		local pid=""
		for pid in ${pidlist}
		do
			kill -"${STOPSIG}" "${pid}" 2>/dev/null
			local delay="${KILLDELAY}"
			local dtime="0"
			# Give it time to exit based on KILLDELAY and break
			# out of the while so that we do not waste
			# unnecessary time (KILLDELAY)
			while [ "${dtime}" -lt "${delay}" ]
			do
				kill -0 "${pid}" 2>/dev/null || break
				sleep 1
				dtime=$((${dtime}+1))
			done

			# Kill remaining pid's with fallback

			if [ -n "${FALLBACK}" ]
			then
				kill -${FALLBACK} ${pid} 2>/dev/null
			fi
		done

		# Check to see if anything is still here
		getpids "${1}"
		if [ "${nopid}" = "0" ]
		then
			failure=0

			if [ -n "${PIDFILE}" -a -e "${PIDFILE}" ]
			then
				rm -f "${PIDFILE}"
			fi

			# Base is inherited from getpids, if pidof was used
			if [ -n "${base}" -a -e "/var/run/$base.pid" ]
			then
				rm -f "/var/run/${base}.pid"
			fi
		else
			failure="1"
		fi

		(exit ${failure})

		if [ "${2}" != "-nomsg" ]
		then
			evaluate_retval
		fi
	else
		if [ "${2}" != "-nomsg" ]
		then
			boot_mesg "Process ${2} not running." ${WARNING}
			echo_warning
		fi
	fi
}

reloadproc()
{
	if [ "${#}" = "0" ]
	then
		echo "Usage: reloadproc [{program}]"
		exit 1
	fi

	getpids "${1}"

	if [ -n "${pidlist}" ]
	then
		failure="0"
		for pid in ${pidlist}
		do
			kill -"${RELOADSIG}" "${pid}" || failure="1"
		done

		(exit ${failure})
		evaluate_retval
	else
		boot_mesg "Process ${2} not running." ${WARNING}
		echo_warning
	fi
}

statusproc()
{
	if [ "${#}" = "0" ]
	then
		echo "Usage: statusproc {program}"
		exit 1
	fi

	getpids "${1}"

	if [ -n "${pidlist}" ]
	then
		echo -e -n "${INFO}"
		echo "${base} is running with Process ID(s) ${pidlist}."
		echo -e -n "${NORMAL}"
	else
		if [ -n "${base}" -a -e "/var/run/${base}.pid" ]
		then
			echo -e -n "${INFO}"
			echo "${1} is not running but /var/run/${base}.pid exists." ${WARNING}
			echo -e -n "${NORMAL}"
		else
			if [ -n "${PIDFILE}" -a -e "${PIDFILE}" ]
			then
				echo -e -n "${INFO}"
				echo "${1} is not running but ${PIDFILE} exists." ${WARNING}
				echo -e -n "${NORMAL}"
			else
				echo -e -n "${INFO}"
				echo "${1} is not running." ${INFO}
				echo -e -n "${NORMAL}"
			fi
		fi
	fi
}

# End $rc_base/init.d/functions
