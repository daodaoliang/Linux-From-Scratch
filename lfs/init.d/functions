#!/bin/sh
# Begin $rc_base/init.d/functions - Run Level Control Functions

# Based on functions script from LFS-3.1 and earlier.
# Rewritten by Gerard Beekmans  - gerard@linuxfromscratch.org

# With code based on Matthias Benkmann's simpleinit-msb @
# http://winterdrache.de/linux/newboot/index.html

## Environmental setup
# Setup default values for environment
umask 022
export PATH="/bin:/usr/bin:/sbin:/usr/sbin"

# Default values for kill function
STOPSIG="TERM"  # Initial Stop Signal
FALLBACK="KILL" # Fallback if STOPSIG does not stop a process in time (see KILLDELAY)
RELOADSIG="HUP" # Signal sent to running processes to refresh their configuration
KILLDELAY="3"   # Number of seconds between STOPSIG and FALLBACK when stopping processes
PIDFILE=""

## Screen Dimentions
if [ -z "$COLUMNS" ]; then
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
fi
# When using remote connections, such as a serial port, stty size returns 0
if [ "$COLUMNS" = "0" ]; then COLUMNS=80; fi
# Measurements for positioning result messages
COL=$(($COLUMNS - 10))
WCOL=$(($COLUMNS - 30))

# Set Cursur Position Commands, used via echo -e
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"  # Up one line, at the 0'th char

# Set color commands, used via echo -e
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
BRACKET="\\033[1;34m"        # Brackets are blue

# Set screen and bootlog message values to ero
BOOTMESG=""
BOOTSERVICE=""

#*******************************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $@ is the message
#
# Outputs:      Standard Output
#
# Dependencies: - grep, for counting \n's in a variable
#               - $WCOL, for max line length, from functions
#
# Todo:         - This function was created for the purpose of storing
#               information to be passed to a bootup log.  The logging support
#               is not yet added
#               - May later have optional color parameter sent via $2.  Using
#               quotes when calling this function shall force all input to be
#               sent to $1 to be compatible with future versions
#
#*******************************************************************************
boot_mesg()
{
	# First call to boot_mesg, set BOOTMESG normally
	if [ -z "$BOOTMESG" ]; then
		BOOTMESG="$@"
	# Subsequent calls will overwrite the text already on the screen
	# with replacement text by counting the lines in the last BOOTMESG
	# and calling CURS_UP that many times
	# It will also append our new text onto the BOOTMESG variable
	else
		local length=`echo -e "$BOOTMESG" | grep -c \$`
		local count=0
		BOOTMESG="$BOOTMESG$@"
		while [ "${count}" -lt "${length}" ]; do
			echo -e -n "$CURS_UP"
			count=$((${count}+1))
		done
	fi

	# This will limit BOOTMESG to be no longer then what WCOL is set to,
	# by adding \n's where appropriate.
	BOOTMESG=`echo ${BOOTMESG} | sed -n -e "s/\\\\n/\n/g;L ${WCOL}"`

	echo -e "${BOOTMESG}"
}

echo_ok()
{
	echo -e "${CURS_UP}""${SET_COL}""${BRACKET}""[""${SUCCESS}""  OK  ""${BRACKET}""]""${NORMAL}"
}

echo_failure()
{
	echo -e "${CURS_UP}""${SET_COL}""${BRACKET}""[""${FAILURE}""FAILED""${BRACKET}""]""${NORMAL}"
}

echo_warning()
{
	echo -e "${CURS_UP}""${SET_WCOL}""$@""${SET_COL}""${BRACKET}""[""${WARNING}"" WARN ""${BRACKET}""]""${NORMAL}"
}

print_error_msg()
{
	# $i is inherited by the rc script
	echo -e -n $FAILURE
	echo
	echo "You should not be reading this error message. It means"
	echo "that an unforseen error took place in $i,"
	echo "which exited with a return value of $error_value"
	echo
	echo "If you're able to track this error down to a bug in one"
	echo "of the files provided by the LFS book, please be so kind"
	echo "to inform us at lfs-dev@linuxfromscratch.org."
	echo -e -n $NORMAL
	echo
	echo
	echo "Press Enter to continue..."
	read ENTER
}

check_script_status()
{
	# $i is inherited by the rc script
	if [ ! -f $i ];	then
		echo "$i is not a valid symlink"
		continue
	fi

	if [ ! -x $i ]; then
		echo "$i is not executable, skipping"
		continue
	fi
}

evaluate_retval()
{
	error_value="$?"

	if [ $error_value = 0 ]; then
		print_status success
	else
		print_status failure
		sleep 5 # To be removed upon completion of logging abilities
	fi

	# This prevents the 'An Unexpected Error Has Occurred' from trivial errors
	return 0
}

print_status()
{
	if [ "$#" = "0" ]; then
		echo "Usage: $0 {success|warning|failure}"
		return 1
	fi

	case "$1" in

		success)
			echo_ok
		;;

		warning)
			case "$2" in

				running)
					echo_warning "Already running"
				;;

				not_running)
					echo_warning "Not running"
				;;

				not_available)
					echo_warning "Not available"
				;;

			esac
		;;

		failure)
			echo_failure
		;;

	esac

	# Reset BOOTMESG to keep from bleeding over again
	BOOTMESG=""
}

# Returns all of the pid #'s for $1 process
getpids()
{
	# Setup Environment
	local lpids=""
	local pid=""
	pidlist=""
	nopid=""

	# If PIDFILE is set, then we get our pidlist from there
	if [ -n "${PIDFILE}" ]; then
		lpids="$(cat $PIDFILE 2>/dev/null)"
		if [ "$?" = "0" ]; then
			# Sometimes we may have a stale PIDFILE, verify that all pids
			# are valid
			for pid in $lpids; do
				kill -0 $pid 2>/dev/null && pidlist="$pidlist $pid"
			done
			if [ -z "$pidlist" ]; then
				nopid="0"
			else
				nopid="1"
			fi
		else
			nopid="0"
		fi
	# Else, we get our pidlist from pidof
	else
		# Strip any thing after the program name so we know what
		# name to throw at pidof
		base="${1##*/}"
		local pid=""
		local lpids=""

		lpids=$(pidof $base)
		# Use the return value of pidof above
		# if the list is empty then we are not running and
		# the return value is 1, else nopid is false
		if [ "$?" = "0" ]; then
			nopid="1"
			for pid in $lpids; do
				if [ "$pid" -ne "$$" -a "$pid" -ne "$PPID" ]; then 
					pidlist="$pidlist $pid"
				fi
			done
		else
			nopid="0"
		fi
	fi
}

# Starts a program if it is currently not running
loadproc()
{
	if [ "$#" = "0" ]; then
		echo "Usage: loadproc {program}"
		exit 1
	fi

	getpids "$1"

	if [ "$nopid" = "0" ]; then
		"$@"
		evaluate_retval
	else
		print_status warning running
	fi
}

# Stops a process if it is running
killproc()
{
	if [ -z "$PIDFILE" -a -z "$#" ]; then
		echo "Usage: killproc [{program}]"
		exit 1	
	fi

	getpids "$1"

	# Send the SIGSTOP to the running process list
	if [ -n "$pidlist" ]; then
		local pid=""
		for pid in $pidlist; do
			kill -"$STOPSIG" "$pid" 2>/dev/null
			local delay="${KILLDELAY}"
			local dtime="0"
			# Give it time to exit based on KILLDELAY and break
			# out of the while so that we do not waste
			# unnecessary time (KILLDELAY)
			while [ "${dtime}" -lt "${delay}" ]; do
				kill -0 "${pid}" 2>/dev/null || break
				sleep 1
				dtime=$((${dtime}+1))
			done

			# Kill remaining pid's with fallback

			if [ -n "$FALLBACK" ]; then
				kill -$FALLBACK $pid 2>/dev/null
			fi
		done

		# Check to see if anything is still here
		getpids "$1"
		if [ "${nopid}" = "0" ]; then
			failure=0

			if [ -n "${PIDFILE}" -a -e "${PIDFILE}" ]; then
				rm -f "${PIDFILE}"
			fi

			# Base is inherited from getpids, if pidof was used
			if [ -n "${base}" -a -e "/var/run/$base.pid" ]; then
				rm -f "/var/run/${base}.pid"
			fi
		else
			failure="1"
		fi

		(exit $failure)
		evaluate_retval
	else
		print_status warning not_running
	fi
}

reloadproc()
{
	if [ "$#" = "0" ]; then
		echo "Usage: reloadproc [{program}]"
		exit 1
	fi

	getpids "$1"

	if [ -n "$pidlist" ]; then
		failure="0"
		for pid in $pidlist; do
			kill -"${RELOADSIG}" "${pid}" || failure="1"
		done

		(exit $failure)
		evaluate_retval
	else
		print_status warning not_running
	fi
}

statusproc()
{
	if [ "$#" = "0" ]; then
		echo "Usage: statusproc {program}"
		exit 1
	fi

	getpids "$1"

	if [ -n "${pidlist}" ]; then
		echo "${base} is running with Process ID(s) ${pidlist}"
	else
		if [ -n "${base}" -a -e "/var/run/$base.pid" ]; then
			echo "$1 is not running but /var/run/$base.pid exists."
		else
			if [ -n "${PIDFILE}" -a -e "${PIDFILE}" ]; then
				echo "$1 is not running but ${PIDFILE} exists."
			else
				echo "$1 is not running."
			fi
		fi
	fi
}

# End $rc_base/init.d/functions
